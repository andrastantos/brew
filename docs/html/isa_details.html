<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Instruction Set Details &mdash; Brew processor  documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/default.js"></script>
        <script src="_static/wavedrom.min.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Floating point support" href="floating_point_support.html" />
    <link rel="prev" title="Memory Model" href="memory_model.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="index.html" class="icon icon-home"> Brew processor
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="execution_contexts.html">Task and Scheduler modes</a></li>
<li class="toctree-l1"><a class="reference internal" href="exceptions.html">Exceptions and Interrupts</a></li>
<li class="toctree-l1"><a class="reference internal" href="process_isolation.html">Process isolation</a></li>
<li class="toctree-l1"><a class="reference internal" href="registers.html">Registers</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html">Types and their manipulation</a></li>
<li class="toctree-l1"><a class="reference internal" href="types.html#type-compatibility">Type compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="control_flow.html">Control flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="isa_intro.html">Instruction Set Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="isa.html">Instruction Set Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="memory_model.html">Memory Model</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Instruction Set Details</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#type-handling">Type handling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#standard-type-determination-and-coalescing">Standard Type Determination and Coalescing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logic-type-determination-and-coalescing">Logic Type Determination and Coalescing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#shift-type-determination-and-coalescing">Shift Type Determination and Coalescing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#load-type-determination-and-coalescing">Load Type Determination and Coalescing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#store-type-handling">Store Type Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#conditional-branch-type-handling">Conditional Branch Type Handling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#swi-0">SWI 0</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#description">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#swi-1">SWI 1</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id4">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#swi-2">SWI 2</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#swi-3">SWI 3</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id8">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#swi-4">SWI 4</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id10">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#swi-5">SWI 5</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id12">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#swi-6">SWI 6</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id14">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#swi-7">SWI 7</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id16">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#stm">STM</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id18">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#woi">WOI</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id20">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pflush">PFLUSH</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id22">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-rw-rw">FENCE_RW_RW</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id25">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-w-rw">FENCE__W_RW</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id27">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-r-rw">FENCE_R__RW</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id29">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-rw">FENCE____RW</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id31">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-rw-w">FENCE_RW__W</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id33">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-w-w">FENCE__W__W</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id35">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-r-w">FENCE_R___W</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id37">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-w">FENCE_____W</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id39">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-rw-r">FENCE_RW_R_</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id41">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-w-r">FENCE__W_R_</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id43">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-r-r">FENCE_R__R_</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id45">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fence-r">FENCE____R_</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id47">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id48">FENCE_RW___</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id50">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id51">FENCE__W___</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id53">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id54">FENCE_R____</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id56">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pc-rd">$pc &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id57">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tpc-rd">$tpc &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id58">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-pc">$rD &lt;- $pc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id59">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-tpc">$rD &lt;- $tpc</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id60">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-csr-addr">$rD &lt;- CSR[ADDR]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id61">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#csr-addr-rd">CSR[ADDR] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id62">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-tiny-const">$rD &lt;- tiny CONST</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id63">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-pc-const">$rD &lt;- $pc + CONST</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id64">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-ra">$rD &lt;- -$rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id65">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-notra">$rD &lt;- ~$rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id67">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-bse-ra">$rD &lt;- bse $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id68">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-wse-ra">$rD &lt;- wse $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id69">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-popcnt-ra">$rD &lt;- popcnt $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id70">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-1-ra">$rD &lt;- 1 / $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id72">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-rsqrt-ra">$rD &lt;- rsqrt $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id74">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#type-rd-ra">type $rD &lt;- $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id76">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-type-ra">$rD &lt;- type $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id77">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#type-rd-field-a">type $rD &lt;- FIELD_A</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id78">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-value">$rD &lt;- VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id80">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pc-value">$pc &lt;- VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id81">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tpc-value">$tpc &lt;- VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id82">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#type-r0-r7-value">type $r0…$r7 &lt;- VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id83">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#type-r8-r14-value">type $r8…$r14 &lt;- VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id84">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-short-value">$rD &lt;- short VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id85">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pc-short-value">$pc &lt;- short VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id86">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tpc-short-value">$tpc &lt;- short VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id87">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#call-short-value">call short VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id89">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#call-value">call VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id91">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-ra-0-pc-pc-value">if any $rA == 0  $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id92">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-ra-ne-0-pc-eq-pc-plus-value">if any $rA != 0  $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id95">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-ra-lt-0-pc-eq-pc-plus-value">if any $rA &lt; 0   $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id98">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-ra-ge-0-pc-eq-pc-plus-value">if any $rA &gt;= 0  $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id101">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-ra-gt-0-pc-eq-pc-plus-value">if any $rA &gt; 0   $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id104">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-ra-le-0-pc-eq-pc-plus-value">if any $rA &lt;= 0  $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id107">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-ra-0-pc-pc-value">if all $rA == 0  $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id109">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-ra-ne-0-pc-eq-pc-plus-value">if all $rA != 0  $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id112">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-ra-lt-0-pc-eq-pc-plus-value">if all $rA &lt; 0   $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id115">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-ra-ge-0-pc-eq-pc-plus-value">if all $rA &gt;= 0  $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id118">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-ra-gt-0-pc-eq-pc-plus-value">if all $rA &gt; 0   $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id121">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-ra-le-0-pc-eq-pc-plus-value">if all $rA &lt;= 0  $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id124">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-rb-ra-pc-pc-value">if any $rB == $rA   $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id126">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-rb-ne-ra-pc-eq-pc-plus-value">if any $rB != $rA   $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id129">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-signed-rb-ra-pc-pc-value">if any signed $rB &lt; $rA  $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id131">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-signed-rb-ge-ra-pc-eq-pc-plus-value">if any signed $rB &gt;= $rA $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id134">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-rb-lt-ra-pc-eq-pc-plus-value">if any $rB &lt; $rA    $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id137">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-any-rb-ge-ra-pc-eq-pc-plus-value">if any $rB &gt;= $rA   $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id140">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-rb-ra-pc-pc-value">if all $rB == $rA   $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id142">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-rb-ne-ra-pc-eq-pc-plus-value">if all $rB != $rA   $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id145">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-signed-rb-ra-pc-pc-value">if all signed $rB &lt; $rA  $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id147">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-signed-rb-ge-ra-pc-eq-pc-plus-value">if all signed $rB &gt;= $rA $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id150">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-rb-lt-ra-pc-eq-pc-plus-value">if all $rB &lt; $rA    $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id153">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-all-rb-ge-ra-pc-eq-pc-plus-value">if all $rB &gt;= $rA   $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id156">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-ra-c-1-pc-pc-value">if $rA[C]  == 1 $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id158">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#if-rb-c-0-pc-pc-value">if $rB[C]  == 0 $pc &lt;- $pc + VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id159">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mem32-rs-tiny-offset-rd">MEM32[$rS + tiny OFFSET] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id160">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-mem32-rs-tiny-offset">$rD &lt;- MEM32[$rS + tiny OFFSET]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id161">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#inv-ra">INV[$rA]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id163">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pc-mem32-ra">$pc &lt;- MEM32[$rA]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id164">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tpc-mem32-ra">$tpc &lt;- MEM32[$rA]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id165">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#call-mem32-ra">call MEM32[$rA]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id166">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#inv-ra-value">INV[$rA + VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id167">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pc-mem32-ra-value">$pc &lt;- MEM32[$rA + VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id168">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tpc-mem32-ra-value">$tpc &lt;- MEM32[$rA + VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id169">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#call-mem32-ra-value">call MEM32[$rA + VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id170">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#inv-value">INV[VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id172">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pc-mem32-value">$pc &lt;- MEM32[VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id173">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#tpc-mem32-value">$tpc &lt;- MEM32[VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id174">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#call-mem32-value">call MEM32[VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id175">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-mem8-ra">$rD &lt;- MEM8[$rA]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id176">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-mem16-ra">$rD &lt;- MEM16[$rA]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id177">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-mem32-ra">$rD &lt;- MEM32[$rA]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id178">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-memll-ra">$rD &lt;- MEMLL[$rA]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id179">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mem8-ra-rd">MEM8[$rA] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id180">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mem16-ra-rd">MEM16[$rA] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id181">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mem32-ra-rd">MEM32[$rA] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id182">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memsc-ra-rd">MEMSC[$rA] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id183">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-smem8-ra">$rD &lt;- SMEM8[$rA]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id184">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-smem16-ra">$rD &lt;- SMEM16[$rA]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id185">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-mem8-ra-value">$rD &lt;- MEM8[$rA + VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id186">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-mem8-value">$rD &lt;- MEM8[VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id187">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-mem16-ra-value">$rD &lt;- MEM16[$rA + VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id188">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-mem16-value">$rD &lt;- MEM16[VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id189">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-mem32-ra-value">$rD &lt;- MEM32[$rA + VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id190">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-mem32-value">$rD &lt;- MEM32[VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id191">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-memll-ra-value">$rD &lt;- MEMLL[$rA + VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id192">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-memll-value">$rD &lt;- MEMLL[VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id193">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mem8-ra-value-rd">MEM8[$rA + VALUE] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id194">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mem8-value-rd">MEM8[VALUE] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id195">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mem16-ra-value-rd">MEM16[$rA + VALUE] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id196">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mem16-value-rd">MEM16[VALUE] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id197">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mem32-ra-value-rd">MEM32[$rA + VALUE] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id198">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#mem32-value-rd">MEM32[VALUE] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id199">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memsc-ra-value-rd">MEMSC[$rA + VALUE] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id200">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#memsc-value-rd">MEMSC[VALUE] &lt;- $rD</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id201">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-smem8-ra-value">$rD &lt;- SMEM8[$rA + VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id202">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-smem8-value">$rD &lt;- SMEM8[VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id203">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-smem16-ra-value">$rD &lt;- SMEM16[$rA + VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id204">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-smem16-value">$rD &lt;- SMEM16[VALUE]</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id205">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-ra-rb">$rD &lt;- $rA ^ $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id206">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-ra-or-rb">$rD &lt;- $rA | $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id208">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-ra-and-rb">$rD &lt;- $rA &amp; $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id210">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-ra-plus-rb">$rD &lt;- $rA + $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id212">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-ra-minus-rb">$rD &lt;- $rA - $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id214">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-ra-lsl-rb">$rD &lt;- $rA &lt;&lt; $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id216">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-ra-lsr-rb">$rD &lt;- $rA &gt;&gt; $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id218">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-ra-asr-rb">$rD &lt;- $rA &gt;&gt;&gt; $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id220">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-ra-times-rb">$rD &lt;- $rA * $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id222">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-type-name-rb">$rD &lt;- TYPE_NAME $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id223">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-tiny-rb-const">$rD &lt;- tiny $rB + CONST</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id225">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-short-value-ra">$rD &lt;- short VALUE ^ $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id226">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-short-value-or-ra">$rD &lt;- short VALUE | $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id228">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-short-value-and-ra">$rD &lt;- short VALUE &amp; $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id230">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-short-value-plus-ra">$rD &lt;- short VALUE + $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id232">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-short-value-minus-ra">$rD &lt;- short VALUE - $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id234">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-short-ra-value">$rD &lt;- short $rA &lt;&lt; VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id235">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-short-ra-lsr-value">$rD &lt;- short $rA &gt;&gt; VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id237">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-short-ra-asr-value">$rD &lt;- short $rA &gt;&gt;&gt; VALUE</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id239">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-short-value-times-ra">$rD &lt;- short VALUE * $rA</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id241">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-value-rb">$rD &lt;- VALUE ^ $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id242">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-value-or-rb">$rD &lt;- VALUE | $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id244">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-value-and-rb">$rD &lt;- VALUE &amp; $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id246">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-value-plus-rb">$rD &lt;- VALUE + $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id248">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-value-minus-rb">$rD &lt;- VALUE - $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id250">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-value-lsl-rb">$rD &lt;- VALUE &lt;&lt; $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id252">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-value-lsr-rb">$rD &lt;- VALUE &gt;&gt; $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id254">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-value-asr-rb">$rD &lt;- VALUE &gt;&gt;&gt; $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id256">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#rd-eq-value-times-rb">$rD &lt;- VALUE * $rB</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id258">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#type-override-type">Type override (&lt;type&gt;)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id259">Description</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#pseudo-instructions">Pseudo instructions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="floating_point_support.html">Floating point support</a></li>
<li class="toctree-l1"><a class="reference internal" href="csrs.html">CSRs</a></li>
<li class="toctree-l1"><a class="reference internal" href="compatibility.html">Family compatibility</a></li>
<li class="toctree-l1"><a class="reference internal" href="abi.html">ABI</a></li>
<li class="toctree-l1"><a class="reference internal" href="hw_impl_notes.html">Appendix A: Implementation Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="system_sw.html">Appendix F: System Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="competition.html">Appendix B: Comparing to the competition</a></li>
<li class="toctree-l1"><a class="reference internal" href="todo.html">Appendix E: Todo</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Brew processor</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home"></a></li>
      <li class="breadcrumb-item active">Instruction Set Details</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="instruction-set-details">
<h1>Instruction Set Details<a class="headerlink" href="#instruction-set-details" title="Permalink to this headline"></a></h1>
<section id="type-handling">
<h2>Type handling<a class="headerlink" href="#type-handling" title="Permalink to this headline"></a></h2>
<section id="standard-type-determination-and-coalescing">
<span id="std-type-handling"></span><h3>Standard Type Determination and Coalescing<a class="headerlink" href="#standard-type-determination-and-coalescing" title="Permalink to this headline"></a></h3>
<p>The type of the up to two operands of the instruction is examined.</p>
<p>If the two types are not <a class="reference internal" href="types.html#type-compatibility"><span class="std std-ref">compatible</span></a>, an <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
<p>The result type is determined by the type of <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> for operations with two register-operand or by the type of the single register-operand if only one exists.</p>
<p>If one of the two input operands is an immediate constant, its type is assumed to be the 32-bit compatible scalar type of the non-immediate operand.</p>
<p>If the instruction has no register operands, only an immediate one, the type of the immediate is assumed to be INT32.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For smaller than 32-bit immediates, the value is sign-extended to 32-bits before a type is assigned to it. This means that such immediates for floating-point operations are rather meaningless, even though the operation itself will be carried out and is considered valid.</p>
</div>
</section>
<section id="logic-type-determination-and-coalescing">
<span id="logic-type-handling"></span><h3>Logic Type Determination and Coalescing<a class="headerlink" href="#logic-type-determination-and-coalescing" title="Permalink to this headline"></a></h3>
<p>For certain logical operations (and, or, xor etc.) the following logic is used to determine the operand and destination types.</p>
<p>The type of the up to two operands of the instruction is examined.</p>
<p>If the <em>logic</em> types of the two operands are not <a class="reference internal" href="types.html#type-compatibility"><span class="std std-ref">compatible</span></a>, an <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
<p>The result type is determined by the type of <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> for operations with two register-operand or by the type of the single register-operand if only one exists.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>the result type determination is asymmetrical in this case. This allows for <code class="code docutils literal notranslate"><span class="pre">$rD</span> <span class="pre">&lt;-</span> <span class="pre">$rA</span> <span class="pre">&amp;</span> <span class="pre">$rB</span></code> and <code class="code docutils literal notranslate"><span class="pre">$rD</span> <span class="pre">&lt;-</span> <span class="pre">$rA</span> <span class="pre">&amp;</span> <span class="pre">~$rB</span></code> operations to maintain the result type, allowing their use as lane-prediction instructions for vector-extensions.</p>
</div>
<p>If one of the two input operands is an immediate constant, its type is assumed to be the 32-bit compatible scalar logic type of the non-immediate operand.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For smaller than 32-bit immediates, the value is sign-extended to 32-bits before a type is assigned to it.</p>
</div>
</section>
<section id="shift-type-determination-and-coalescing">
<span id="shift-type-handling"></span><h3>Shift Type Determination and Coalescing<a class="headerlink" href="#shift-type-determination-and-coalescing" title="Permalink to this headline"></a></h3>
<p>For shift operations the following logic is used to determine the operand and destination types.</p>
<p>If either operand is an immediate value for the instruction, it is assumed to be of type INT32 (even for 16-bit immediates, which are first sign-extended to 32-bits).</p>
<p>The operand type of the second operand (the shift amount) is checked to be of a fixed point type. If not, a <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
<p>The result type is what the first operand (the shift value).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For shift variants, where the shift value is an immediate, the result type will always be INT32.</p>
</div>
</section>
<section id="load-type-determination-and-coalescing">
<span id="load-type-handling"></span><h3>Load Type Determination and Coalescing<a class="headerlink" href="#load-type-determination-and-coalescing" title="Permalink to this headline"></a></h3>
<p>For load operations, the destination type is not altered.</p>
<p>For immediate loads (where the value is part of the instruction), the value is first sign-extended to 32-bits, then assigned to the destination register.</p>
<p>For loads from memory, the length of the load is determined by the operation: 32, 16 or 8 bits are loaded.</p>
<p>The offset register must be of logical type <code class="code docutils literal notranslate"><span class="pre">INT32</span></code>. If not, a <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
</section>
</section>
<section id="store-type-handling">
<span id="id1"></span><h2>Store Type Handling<a class="headerlink" href="#store-type-handling" title="Permalink to this headline"></a></h2>
<p>For store operations, the length of the store is 8- 16- or 32-bits, depending on the operation.</p>
<p>The offset register must be of logical type <code class="code docutils literal notranslate"><span class="pre">INT32</span></code>. If not, a <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
</section>
<section id="conditional-branch-type-handling">
<span id="cbranch-type-handling"></span><h2>Conditional Branch Type Handling<a class="headerlink" href="#conditional-branch-type-handling" title="Permalink to this headline"></a></h2>
<p>Conditional branch operations use <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine source types, but - for obvious reasons - don’t care about the destination type.</p>
</section>
<section id="swi-0">
<span id="id2"></span><h2>SWI 0<a class="headerlink" href="#swi-0" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x0000</p>
<p><em>Alternative syntax</em>: FILL</p>
<p><em>Exceptions</em>: SWI 0</p>
<p><em>Type variants</em>: No</p>
<section id="description">
<h3>Description<a class="headerlink" href="#description" title="Permalink to this headline"></a></h3>
<p>Raises the <code class="code docutils literal notranslate"><span class="pre">exc_swi_0</span></code> exception. Used to fill unused space.</p>
</section>
</section>
<section id="swi-1">
<span id="id3"></span><h2>SWI 1<a class="headerlink" href="#swi-1" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x1000</p>
<p><em>Alternative syntax</em>: BREAK</p>
<p><em>Exceptions</em>: SWI 1</p>
<p><em>Type variants</em>: No</p>
<section id="id4">
<h3>Description<a class="headerlink" href="#id4" title="Permalink to this headline"></a></h3>
<p>Raises the <code class="code docutils literal notranslate"><span class="pre">exc_swi_1</span></code> exception. Used to implement software breakpoints.</p>
</section>
</section>
<section id="swi-2">
<span id="id5"></span><h2>SWI 2<a class="headerlink" href="#swi-2" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x2000</p>
<p><em>Alternative syntax</em>: SYSCALL</p>
<p><em>Exceptions</em>: SWI 2</p>
<p><em>Type variants</em>: No</p>
<section id="id6">
<h3>Description<a class="headerlink" href="#id6" title="Permalink to this headline"></a></h3>
<p>Raises the <code class="code docutils literal notranslate"><span class="pre">exc_swi_2</span></code> exception. Used to implement operating system calls</p>
</section>
</section>
<section id="swi-3">
<span id="id7"></span><h2>SWI 3<a class="headerlink" href="#swi-3" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x3000</p>
<p><em>Exceptions</em>: SWI 3</p>
<p><em>Type variants</em>: No</p>
<section id="id8">
<h3>Description<a class="headerlink" href="#id8" title="Permalink to this headline"></a></h3>
<p>Raises the <code class="code docutils literal notranslate"><span class="pre">exc_swi_3</span></code> exception.</p>
</section>
</section>
<section id="swi-4">
<span id="id9"></span><h2>SWI 4<a class="headerlink" href="#swi-4" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x4000</p>
<p><em>Exceptions</em>: SWI 4</p>
<p><em>Type variants</em>: No</p>
<section id="id10">
<h3>Description<a class="headerlink" href="#id10" title="Permalink to this headline"></a></h3>
<p>Raises the <code class="code docutils literal notranslate"><span class="pre">exc_swi_4</span></code> exception.</p>
</section>
</section>
<section id="swi-5">
<span id="id11"></span><h2>SWI 5<a class="headerlink" href="#swi-5" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x5000</p>
<p><em>Exceptions</em>: SWI 5</p>
<p><em>Type variants</em>: No</p>
<section id="id12">
<h3>Description<a class="headerlink" href="#id12" title="Permalink to this headline"></a></h3>
<p>Raises the <code class="code docutils literal notranslate"><span class="pre">exc_swi_5</span></code> exception.</p>
</section>
</section>
<section id="swi-6">
<span id="id13"></span><h2>SWI 6<a class="headerlink" href="#swi-6" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x6000</p>
<p><em>Exceptions</em>: SWI 6</p>
<p><em>Type variants</em>: No</p>
<section id="id14">
<h3>Description<a class="headerlink" href="#id14" title="Permalink to this headline"></a></h3>
<p>Raises the <code class="code docutils literal notranslate"><span class="pre">exc_swi_6</span></code> exception.</p>
</section>
</section>
<section id="swi-7">
<span id="id15"></span><h2>SWI 7<a class="headerlink" href="#swi-7" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x7000</p>
<p><em>Exceptions</em>: SWI 7</p>
<p><em>Type variants</em>: No</p>
<section id="id16">
<h3>Description<a class="headerlink" href="#id16" title="Permalink to this headline"></a></h3>
<p>Raises the <code class="code docutils literal notranslate"><span class="pre">exc_swi_7</span></code> exception.</p>
</section>
</section>
<section id="stm">
<span id="id17"></span><h2>STM<a class="headerlink" href="#stm" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x8000</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id18">
<h3>Description<a class="headerlink" href="#id18" title="Permalink to this headline"></a></h3>
<p>Returns execution to TASK mode. If already in TASK mode, the instruction as no effect. Execution continues in TASK mode from the address pointed to by <code class="code docutils literal notranslate"><span class="pre">$tpc</span></code></p>
</section>
</section>
<section id="woi">
<span id="id19"></span><h2>WOI<a class="headerlink" href="#woi" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x9000</p>
<p><em>Exceptions</em>: HWI</p>
<p><em>Type variants</em>: No</p>
<section id="id20">
<h3>Description<a class="headerlink" href="#id20" title="Permalink to this headline"></a></h3>
<p>Wake-on-interrupt. The processor enters a low-power state and waits for an interrupt. When an interrupt occurs, the processor continues execution. This operation waits for an interrupt, even if executed in SCHEDULER mode. In TASK mode, of course once execution is resumed, the processor switches to SCHEDULER mode, due to the pending interrupt.</p>
</section>
</section>
<section id="pflush">
<span id="id21"></span><h2>PFLUSH<a class="headerlink" href="#pflush" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xa000</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id22">
<h3>Description<a class="headerlink" href="#id22" title="Permalink to this headline"></a></h3>
<p>This instruction flushes the internal pipeline. Subsequent instructions must be fetched anew from at least L1 instruction cache. This instruction can be used to enforce proper operation for self-modifying code or for instance when a new executable image is loaded from storage.</p>
<div class="admonition-todo admonition" id="id23">
<p class="admonition-title">Todo</p>
<p>PFLUSH is not implemented anywhere. Not in BINUTILS, not in Espresso.</p>
</div>
</section>
</section>
<section id="fence-rw-rw">
<span id="id24"></span><h2>FENCE_RW_RW<a class="headerlink" href="#fence-rw-rw" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x0001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id25">
<h3>Description<a class="headerlink" href="#id25" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-w-rw">
<span id="id26"></span><h2>FENCE__W_RW<a class="headerlink" href="#fence-w-rw" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x1001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id27">
<h3>Description<a class="headerlink" href="#id27" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-r-rw">
<span id="id28"></span><h2>FENCE_R__RW<a class="headerlink" href="#fence-r-rw" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x2001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id29">
<h3>Description<a class="headerlink" href="#id29" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-rw">
<span id="id30"></span><h2>FENCE____RW<a class="headerlink" href="#fence-rw" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x3001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id31">
<h3>Description<a class="headerlink" href="#id31" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-rw-w">
<span id="id32"></span><h2>FENCE_RW__W<a class="headerlink" href="#fence-rw-w" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x4001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id33">
<h3>Description<a class="headerlink" href="#id33" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-w-w">
<span id="id34"></span><h2>FENCE__W__W<a class="headerlink" href="#fence-w-w" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x5001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id35">
<h3>Description<a class="headerlink" href="#id35" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-r-w">
<span id="id36"></span><h2>FENCE_R___W<a class="headerlink" href="#fence-r-w" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x6001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id37">
<h3>Description<a class="headerlink" href="#id37" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-w">
<span id="id38"></span><h2>FENCE_____W<a class="headerlink" href="#fence-w" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x7001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id39">
<h3>Description<a class="headerlink" href="#id39" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-rw-r">
<span id="id40"></span><h2>FENCE_RW_R_<a class="headerlink" href="#fence-rw-r" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x8001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id41">
<h3>Description<a class="headerlink" href="#id41" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-w-r">
<span id="id42"></span><h2>FENCE__W_R_<a class="headerlink" href="#fence-w-r" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x9001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id43">
<h3>Description<a class="headerlink" href="#id43" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-r-r">
<span id="id44"></span><h2>FENCE_R__R_<a class="headerlink" href="#fence-r-r" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xa001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id45">
<h3>Description<a class="headerlink" href="#id45" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="fence-r">
<span id="id46"></span><h2>FENCE____R_<a class="headerlink" href="#fence-r" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xb001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id47">
<h3>Description<a class="headerlink" href="#id47" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="id48">
<span id="id49"></span><h2>FENCE_RW___<a class="headerlink" href="#id48" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xc001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id50">
<h3>Description<a class="headerlink" href="#id50" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="id51">
<span id="id52"></span><h2>FENCE__W___<a class="headerlink" href="#id51" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xd001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id53">
<h3>Description<a class="headerlink" href="#id53" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="id54">
<span id="id55"></span><h2>FENCE_R____<a class="headerlink" href="#id54" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xe001</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id56">
<h3>Description<a class="headerlink" href="#id56" title="Permalink to this headline"></a></h3>
<p>Every instruction in this group implements a fence, or an ordering between loads and stores. The top-most 4 bits of the instruction code is used the encode the fence type:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 45%" />
<col style="width: 55%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Bit-field</p></th>
<th class="head"><p>Meaning</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>12</p></td>
<td><p>~R-before</p></td>
</tr>
<tr class="row-odd"><td><p>13</p></td>
<td><p>~W-before</p></td>
</tr>
<tr class="row-even"><td><p>14</p></td>
<td><p>~R-after</p></td>
</tr>
<tr class="row-odd"><td><p>15</p></td>
<td><p>~W-after</p></td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>bit-values are inverted to make FIELD_D==0xf an invalid encoding (i.e. no fence specification)</p>
</div>
<p>Fences have no effect on cache contents. In particular, fences don’t invalidate the instruction cache (if exists) and cannot be exclusively used to implement coherency between data and instruction stream such as needed for self-modifying code.</p>
<p>Depending on the implementation, some or all fence operations might be no-ops.</p>
<p>‘Before’ fence operations ensure that all reads and writes complete before the processor is allowed to continue execution. For writes, it is guaranteed that all stored values reached their final destination. ‘Destination’ in this context is anything outside the CPU core that can report a completion of the store. For instance, L1 and L2 caches can report completion in case of a write-back implementation. For reads, it is guaranteed that all values have reached the processor core (but might not yet be committed to the register file).</p>
<p>‘After’ fence operations ensure that none of the reads or writes start execution prior to the completion of the fence instruction. This is a potential issue for out-of-order implementations, where the apparent instruction execution order is different from the actual one. ‘After’ fences can be used to ensure that loads and stores maintain their program-order even in an out-of-order machine.</p>
<p>Care should be taken to ensure proper fence behavior for writes that leave in-order but have their side-effects out-of-order due to latency-differences through the interconnect.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Fences also can’t be trusted for cache-coherency between cores or HW threads if the implementation doesn’t explicitly have such guarantees.</p>
</div>
</section>
</section>
<section id="pc-rd">
<span id="pc-eq-rd"></span><h2>$pc &lt;- $rD<a class="headerlink" href="#pc-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.002</p>
<p><em>Exceptions</em>: implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id57">
<h3>Description<a class="headerlink" href="#id57" title="Permalink to this headline"></a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">$pc</span></code> is loaded with the value in <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. This is an indirect jump. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is ignored and as INT32. The LSB of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A branch operation can obviously cause exceptions, if the branch target is invalid as defined by the memory protection scheme of the implementation. However, in those cases, the exception is raised during the fetch attempt of the target instruction, not during the execution of the branch operation.</p>
</div>
</section>
</section>
<section id="tpc-rd">
<span id="tpc-eq-rd"></span><h2>$tpc &lt;- $rD<a class="headerlink" href="#tpc-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.003</p>
<p><em>Exceptions</em>: implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id58">
<h3>Description<a class="headerlink" href="#id58" title="Permalink to this headline"></a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">$tpc</span></code> is loaded with the value in <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. This is an indirect jump in TASK mode. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is ignored and as INT32. The LSB of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
</section>
</section>
<section id="rd-pc">
<span id="rd-eq-pc"></span><h2>$rD &lt;- $pc<a class="headerlink" href="#rd-pc" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.004</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id59">
<h3>Description<a class="headerlink" href="#id59" title="Permalink to this headline"></a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded with the value in <code class="code docutils literal notranslate"><span class="pre">$pc</span></code>, which points to the currently executing instruction. The LSB loaded into <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> carries implementation-defined meaning. There’s no guarantee that the LSB is preserved between a pair of <code class="code docutils literal notranslate"><span class="pre">$pc</span> <span class="pre">&lt;-</span> <span class="pre">$rD</span></code> and <code class="code docutils literal notranslate"><span class="pre">$rD</span> <span class="pre">&lt;-</span> <span class="pre">$pc</span></code> instructions. If the implementation doesn’t define a meaning, the LSB will be loaded with 0. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is set to INT32.</p>
</section>
</section>
<section id="rd-tpc">
<span id="rd-eq-tpc"></span><h2>$rD &lt;- $tpc<a class="headerlink" href="#rd-tpc" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.005</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id60">
<h3>Description<a class="headerlink" href="#id60" title="Permalink to this headline"></a></h3>
<p><code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded with the value in <code class="code docutils literal notranslate"><span class="pre">$tpc</span></code>. In TASK-mode, this will be the address of the currently executing instruction. The LSB loaded into <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> carries implementation-defined meaning. There’s no guarantee that the LSB is preserved between a pair of <code class="code docutils literal notranslate"><span class="pre">$tpc</span> <span class="pre">&lt;-</span> <span class="pre">$rD</span></code> and <code class="code docutils literal notranslate"><span class="pre">$rD</span> <span class="pre">&lt;-</span> <span class="pre">$tpc</span></code> instructions. If the implementation doesn’t define a meaning, the LSB will be loaded with 0. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is set to INT32.</p>
</section>
</section>
<section id="rd-csr-addr">
<span id="rd-eq-csr-addr"></span><h2>$rD &lt;- CSR[ADDR]<a class="headerlink" href="#rd-csr-addr" title="Permalink to this headline"></a></h2>

<div style="overflow-x:auto">
<script type="WaveDrom">
{config: {bits: 16}, config: {hspace: 500},
reg: [
    { "name": "8",         "bits": 4 },
    { "name": "f",         "bits": 4 },
    { "name": "0",         "bits": 4 },
    { "name": "FIELD_D",   "bits": 4, attr: "$rD" },
]}
</script>
</div>

<div style="overflow-x:auto">
<script type="WaveDrom">
{config: {bits: 16}, config: {hspace: 500},
reg: [
    { "name": "FIELD_E", "bits": 16 },
],
}
</script>
</div>
<p><em>Instruction code</em>: 0x.0f8 0x****</p>
<p><em>Exceptions</em>: implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id61">
<h3>Description<a class="headerlink" href="#id61" title="Permalink to this headline"></a></h3>
<p>Load <a class="reference internal" href="csrs.html#csr"><span class="std std-ref">CSR</span></a> value, specified by FIELD_E into $rD. In TASK mode the MSB of the CSR address is always set to 1. In SCHEDULER mode, the MSB is determined by bit 15 of FIELD_E. This way, only CSRs between 0x8000 and 0xffff are accessible from TASK mode, while all 65536 CSR locations are accessible for SCHEDULE mode code.</p>
<p>All CSRs are 32-bit wide. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is handled per <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> rules. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is not altered.</p>
</section>
</section>
<section id="csr-addr-rd">
<span id="csr-addr-eq-rd"></span><h2>CSR[ADDR] &lt;- $rD<a class="headerlink" href="#csr-addr-rd" title="Permalink to this headline"></a></h2>

<div style="overflow-x:auto">
<script type="WaveDrom">
{config: {bits: 16}, config: {hspace: 500},
reg: [
    { "name": "9",         "bits": 4 },
    { "name": "f",         "bits": 4 },
    { "name": "0",         "bits": 4 },
    { "name": "FIELD_D",   "bits": 4, attr: "$rD" },
]}
</script>
</div>

<div style="overflow-x:auto">
<script type="WaveDrom">
{config: {bits: 16}, config: {hspace: 500},
reg: [
    { "name": "FIELD_E", "bits": 16 },
],
}
</script>
</div>
<p><em>Instruction code</em>: 0x.0f9 0x****</p>
<p><em>Exceptions</em>: implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id62">
<h3>Description<a class="headerlink" href="#id62" title="Permalink to this headline"></a></h3>
<p>Store $rD in the specified <a class="reference internal" href="csrs.html#csr"><span class="std std-ref">CSR</span></a> specified by FIELD_E. In TASK mode the MSB of the CSR address is always set to 1. In SCHEDULER mode, the MSB is determined by bit 15 of FIELD_E. This way, only CSRs between 0x8000 and 0xffff are accessible from TASK mode, while all 65536 CSR locations are accessible for SCHEDULE mode code.</p>
<p>All CSRs are 32-bit wide. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is handled per <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> rules.</p>
</section>
</section>
<section id="rd-tiny-const">
<span id="rd-eq-tiny-const"></span><h2>$rD &lt;- tiny CONST<a class="headerlink" href="#rd-tiny-const" title="Permalink to this headline"></a></h2>

<div style="overflow-x:auto">
<script type="WaveDrom">
{config: {bits: 16}, config: {hspace: 500},
reg: [
    { "name": "FIELD_A",   "bits": 4, attr: "CONST" },
    { "name": "1",         "bits": 4 },
    { "name": "0",         "bits": 4 },
    { "name": "FIELD_D",   "bits": 4, attr: "$rD" },
]}
</script>
</div>
<p><em>Instruction code</em>: 0x.01.</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: Yes</p>
<section id="id63">
<h3>Description<a class="headerlink" href="#id63" title="Permalink to this headline"></a></h3>
<p>The immediate CONST is stored in FIELD_A. Constant value is one-s complement of FIELD_A. Range is -7 to +7, which is sign-extended to 32 bits.</p>
</section>
</section>
<section id="rd-pc-const">
<span id="rd-eq-pc-plus-const"></span><h2>$rD &lt;- $pc + CONST<a class="headerlink" href="#rd-pc-const" title="Permalink to this headline"></a></h2>

<div style="overflow-x:auto">
<script type="WaveDrom">
{config: {bits: 16}, config: {hspace: 500},
reg: [
    { "name": "FIELD_A",   "bits": 4, attr: "CONST" },
    { "name": "2",         "bits": 4 },
    { "name": "0",         "bits": 4 },
    { "name": "FIELD_D",   "bits": 4, attr: "$rD" },
]}
</script>
</div>
<p><em>Instruction code</em>: 0x.02.</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: Yes</p>
<section id="id64">
<h3>Description<a class="headerlink" href="#id64" title="Permalink to this headline"></a></h3>
<p>Load $rD with $pc + constant stored in FIELD_A. Constant value is twice the one-s complement of FIELD_A. Range is -14 to +14, which is sign-extended to 32 bits. Useful for call return address calculation. The destination type is set to INT32.</p>
</section>
</section>
<section id="rd-ra">
<span id="rd-eq-minus-ra"></span><h2>$rD &lt;- -$rA<a class="headerlink" href="#rd-ra" title="Permalink to this headline"></a></h2>

<div style="overflow-x:auto">
<script type="WaveDrom">
{config: {bits: 16}, config: {hspace: 500},
reg: [
    { "name": "FIELD_A",   "bits": 4, attr: "$rA" },
    { "name": "3",         "bits": 4 },
    { "name": "0",         "bits": 4 },
    { "name": "FIELD_D",   "bits": 4, attr: "$rD" },
]}
</script>
</div>
<p><em>Instruction code</em>: 0x.03.</p>
<p><em>Exceptions</em>: None</p>
<section id="id65">
<h3>Description<a class="headerlink" href="#id65" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting type either an integer or a float-point lane-wise negation is performed.</p>
</section>
</section>
<section id="rd-eq-notra">
<span id="id66"></span><h2>$rD &lt;- ~$rA<a class="headerlink" href="#rd-eq-notra" title="Permalink to this headline"></a></h2>

<div style="overflow-x:auto">
<script type="WaveDrom">
{config: {bits: 16}, config: {hspace: 500},
reg: [
    { "name": "FIELD_A",   "bits": 4, attr: "$rA" },
    { "name": "4",         "bits": 4 },
    { "name": "0",         "bits": 4 },
    { "name": "FIELD_D",   "bits": 4, attr: "$rD" },
]}
</script>
</div>
<p><em>Instruction code</em>: 0x.04.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>       <span class="mi">4</span>       <span class="o">|</span>    <span class="n">FIELD_A</span>    <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id67">
<h3>Description<a class="headerlink" href="#id67" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting type a bit-wise inversion is performed.</p>
</section>
</section>
<section id="rd-bse-ra">
<span id="rd-eq-bse-ra"></span><h2>$rD &lt;- bse $rA<a class="headerlink" href="#rd-bse-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.05.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>       <span class="mi">5</span>       <span class="o">|</span>    <span class="n">FIELD_A</span>    <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: Yes</p>
<section id="id68">
<h3>Description<a class="headerlink" href="#id68" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting type a lane-wise sign-extension from 8 bits to the lane width is performed. If the lane-width is less then or equal to 8 bits, the operation simply assigns the input to the output.</p>
</section>
</section>
<section id="rd-wse-ra">
<span id="rd-eq-wse-ra"></span><h2>$rD &lt;- wse $rA<a class="headerlink" href="#rd-wse-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.06.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>       <span class="mi">6</span>       <span class="o">|</span>    <span class="n">FIELD_A</span>    <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: Yes</p>
<section id="id69">
<h3>Description<a class="headerlink" href="#id69" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting type a lane-wise sign-extension from 16 bits to the lane width is performed. If the lane-width is less then or equal to 16 bits, the operation simply assigns the input to the output.</p>
</section>
</section>
<section id="rd-popcnt-ra">
<span id="rd-eq-popcnt-ra"></span><h2>$rD &lt;- popcnt $rA<a class="headerlink" href="#rd-popcnt-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.07.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>       <span class="mi">7</span>       <span class="o">|</span>    <span class="n">FIELD_A</span>    <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id70">
<h3>Description<a class="headerlink" href="#id70" title="Permalink to this headline"></a></h3>
<p>Write the number of bits set in $rA into $rD.</p>
<div class="admonition-todo admonition" id="id71">
<p class="admonition-title">Todo</p>
<p>This is a new instruction. No toolset support at the moment.</p>
</div>
</section>
</section>
<section id="rd-1-ra">
<span id="rd-eq-1-ra"></span><h2>$rD &lt;- 1 / $rA<a class="headerlink" href="#rd-1-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.08.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>       <span class="mi">8</span>       <span class="o">|</span>    <span class="n">FIELD_A</span>    <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id72">
<h3>Description<a class="headerlink" href="#id72" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. If the input type is not of a floating point type, an <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
<p>After the types are determined, the reciprocal of each lane is computed. If a zero value is encountered in an element, the corresponding result is set to <code class="code docutils literal notranslate"><span class="pre">NaN</span></code>. The <code class="code docutils literal notranslate"><span class="pre">fdv</span></code> status bit in the <a class="reference internal" href="floating_point_support.html#fpstat"><span class="std std-ref">csr_fpstat</span></a> register is set.</p>
<div class="admonition-todo admonition" id="id73">
<p class="admonition-title">Todo</p>
<p>Instruction code changed. Needs toolset update.</p>
</div>
</section>
</section>
<section id="rd-rsqrt-ra">
<span id="rd-eq-rsqrt-ra"></span><h2>$rD &lt;- rsqrt $rA<a class="headerlink" href="#rd-rsqrt-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.09.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>       <span class="mi">9</span>       <span class="o">|</span>    <span class="n">FIELD_A</span>    <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id74">
<h3>Description<a class="headerlink" href="#id74" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. If the input type is not of a floating point type, an <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
<p>After the types are determined, the reciprocal-square-root of each lane is computed. If a non-positive value is encountered in an element, the corresponding result is set to <code class="code docutils literal notranslate"><span class="pre">NaN</span></code>. The <code class="code docutils literal notranslate"><span class="pre">fnv</span></code> status bit in the <a class="reference internal" href="floating_point_support.html#fpstat"><span class="std std-ref">csr_fpstat</span></a> register is set.</p>
<div class="admonition-todo admonition" id="id75">
<p class="admonition-title">Todo</p>
<p>Instruction code changed. Needs toolset update.</p>
</div>
</section>
</section>
<section id="type-rd-ra">
<span id="type-rd-eq-ra"></span><h2>type $rD &lt;- $rA<a class="headerlink" href="#type-rd-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.0c.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>       <span class="n">c</span>       <span class="o">|</span>    <span class="n">FIELD_A</span>    <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id76">
<h3>Description<a class="headerlink" href="#id76" title="Permalink to this headline"></a></h3>
<p>Sets type of $rD as denoted by $rA. All 32 bits of <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> are meaningful in this instruction. If an unsupported type is specified, a <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-type-ra">
<span id="rd-eq-type-ra"></span><h2>$rD &lt;- type $rA<a class="headerlink" href="#rd-type-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.0d.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>       <span class="n">d</span>       <span class="o">|</span>    <span class="n">FIELD_A</span>    <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id77">
<h3>Description<a class="headerlink" href="#id77" title="Permalink to this headline"></a></h3>
<p>Loads type value of $rA into $rD. The type of $rA is set to INT32.</p>
</section>
</section>
<section id="type-rd-field-a">
<span id="type-rd-eq-field-a"></span><h2>type $rD &lt;- FIELD_A<a class="headerlink" href="#type-rd-field-a" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.0e.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>       <span class="mi">0</span>       <span class="o">|</span>       <span class="n">e</span>       <span class="o">|</span>    <span class="n">FIELD_A</span>    <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id78">
<h3>Description<a class="headerlink" href="#id78" title="Permalink to this headline"></a></h3>
<p>Sets type of $rD as denoted by FIELD_A. If an unsupported type is specified, a <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
<div class="admonition-todo admonition" id="id79">
<p class="admonition-title">Todo</p>
<p>assembly should use descriptive type names, instead of numeric values.</p>
</div>
</section>
</section>
<section id="rd-value">
<span id="rd-eq-value"></span><h2>$rD &lt;- VALUE<a class="headerlink" href="#rd-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.00f 0x**** 0x****</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: Yes</p>
<section id="id80">
<h3>Description<a class="headerlink" href="#id80" title="Permalink to this headline"></a></h3>
<p>Loads <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> with the value of FIELD_E. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is not changed. The type of FIELD_E is determined using <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a>.</p>
</section>
</section>
<section id="pc-value">
<span id="pc-eq-value"></span><h2>$pc &lt;- VALUE<a class="headerlink" href="#pc-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x20ef 0x**** 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id81">
<h3>Description<a class="headerlink" href="#id81" title="Permalink to this headline"></a></h3>
<p>Loads <code class="code docutils literal notranslate"><span class="pre">$pc</span></code> with the value of FIELD_E. This is an absolute jump operation. The LSB of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A branch operation can obviously cause exceptions, if the branch target is invalid as defined by the memory protection scheme of the implementation. However, in those cases, the exception is raised during the fetch attempt of the target instruction, not during the execution of the branch operation.</p>
</div>
</section>
</section>
<section id="tpc-value">
<span id="tpc-eq-value"></span><h2>$tpc &lt;- VALUE<a class="headerlink" href="#tpc-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x30ef 0x**** 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id82">
<h3>Description<a class="headerlink" href="#id82" title="Permalink to this headline"></a></h3>
<p>Loads <code class="code docutils literal notranslate"><span class="pre">$tpc</span></code> with the value of FIELD_E. This is an absolute jump operation in TASK mode. The LSB of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A branch operation can obviously cause exceptions, if the branch target is invalid as defined by the memory protection scheme of the implementation. However, in those cases, the exception is raised during the fetch attempt of the target instruction, not during the execution of the branch operation.</p>
</div>
</section>
</section>
<section id="type-r0-r7-value">
<span id="type-r0-r7-eq-value"></span><h2>type $r0…$r7 &lt;- VALUE<a class="headerlink" href="#type-r0-r7-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x80ef 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: No</p>
<section id="id83">
<h3>Description<a class="headerlink" href="#id83" title="Permalink to this headline"></a></h3>
<p>Loads the type of <code class="code docutils literal notranslate"><span class="pre">$r0</span></code> through <code class="code docutils literal notranslate"><span class="pre">$r7</span></code> with the types encoded in each 4-bit niggle of FIELD_E. The lowest 4 bits determine the type of <code class="code docutils literal notranslate"><span class="pre">$r0</span></code>. The highest 4 bits determine the type of <code class="code docutils literal notranslate"><span class="pre">$r7</span></code>. If a nibble has a value of 0xf, the type of the corresponding register is not changed.</p>
<p>If an unsupported (or reserved) type is specified, a <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
</section>
</section>
<section id="type-r8-r14-value">
<span id="type-r8-r14-eq-value"></span><h2>type $r8…$r14 &lt;- VALUE<a class="headerlink" href="#type-r8-r14-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x90ef 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: No</p>
<section id="id84">
<h3>Description<a class="headerlink" href="#id84" title="Permalink to this headline"></a></h3>
<p>Loads the type of <code class="code docutils literal notranslate"><span class="pre">$r8</span></code> through <code class="code docutils literal notranslate"><span class="pre">$r14</span></code> with the types encoded in each 4-bit niggle of FIELD_E. The lowest 4 bits determine the type of <code class="code docutils literal notranslate"><span class="pre">$r8</span></code>. The next-to-highest 4 bits determine the type of <code class="code docutils literal notranslate"><span class="pre">$r14</span></code>. The highest nibble of FIELD_E is ignored. If a nibble has a value of 0xf, the type of the corresponding register is not changed.</p>
<p>If an unsupported (or reserved) type is specified, a <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-short-value">
<span id="rd-eq-short-value"></span><h2>$rD &lt;- short VALUE<a class="headerlink" href="#rd-short-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.0f0 0x****</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: Yes</p>
<section id="id85">
<h3>Description<a class="headerlink" href="#id85" title="Permalink to this headline"></a></h3>
<p>Loads <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> with the value of FIELD_E. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is not changed. The type of FIELD_E is determined using <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a>.</p>
</section>
</section>
<section id="pc-short-value">
<span id="pc-eq-short-value"></span><h2>$pc &lt;- short VALUE<a class="headerlink" href="#pc-short-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x20fe 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id86">
<h3>Description<a class="headerlink" href="#id86" title="Permalink to this headline"></a></h3>
<p>Loads <code class="code docutils literal notranslate"><span class="pre">$pc</span></code> with the sign-extended value of FIELD_E. This is an absolute jump operation. The LSB of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A branch operation can obviously cause exceptions, if the branch target is invalid as defined by the memory protection scheme of the implementation. However, in those cases, the exception is raised during the fetch attempt of the target instruction, not during the execution of the branch operation.</p>
</div>
</section>
</section>
<section id="tpc-short-value">
<span id="tpc-eq-short-value"></span><h2>$tpc &lt;- short VALUE<a class="headerlink" href="#tpc-short-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x30fe 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id87">
<h3>Description<a class="headerlink" href="#id87" title="Permalink to this headline"></a></h3>
<p>Loads <code class="code docutils literal notranslate"><span class="pre">$tpc</span></code> with the sign-extended value of FIELD_E. This is an absolute jump operation in TASK mode. The LSB of the immediate value carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A branch operation can obviously cause exceptions, if the branch target is invalid as defined by the memory protection scheme of the implementation. However, in those cases, the exception is raised during the fetch attempt of the target instruction, not during the execution of the branch operation.</p>
</div>
</section>
</section>
<section id="call-short-value">
<span id="id88"></span><h2>call short VALUE<a class="headerlink" href="#call-short-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x40fe 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id89">
<h3>Description<a class="headerlink" href="#id89" title="Permalink to this headline"></a></h3>
<p>Loads <code class="code docutils literal notranslate"><span class="pre">$pc</span></code> with the sign-extended value of FIELD_E, while loading <code class="code docutils literal notranslate"><span class="pre">$lr</span></code> with the current value of <code class="code docutils literal notranslate"><span class="pre">$pc</span></code>. This is an absolute call operation. The LSB of the immediate value carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A call operation can obviously cause exceptions, if the call target is invalid as defined by the memory protection scheme of the implementation. However, in those cases, the exception is raised during the fetch attempt of the target instruction, not during the execution of the branch operation.</p>
</div>
</section>
</section>
<section id="call-value">
<span id="id90"></span><h2>call VALUE<a class="headerlink" href="#call-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x40ef 0x**** 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id91">
<h3>Description<a class="headerlink" href="#id91" title="Permalink to this headline"></a></h3>
<p>Loads <code class="code docutils literal notranslate"><span class="pre">$pc</span></code> with the 32-bit value of FIELD_E, while loading <code class="code docutils literal notranslate"><span class="pre">$lr</span></code> with the current value of <code class="code docutils literal notranslate"><span class="pre">$pc</span></code>. This is an absolute call operation. The LSB of the immediate value carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>A call operation can obviously cause exceptions, if the call target is invalid as defined by the memory protection scheme of the implementation. However, in those cases, the exception is raised during the fetch attempt of the target instruction, not during the execution of the branch operation.</p>
</div>
</section>
</section>
<section id="if-any-ra-0-pc-pc-value">
<span id="if-any-ra-eq-0-pc-eq-pc-plus-value"></span><h2>if any $rA == 0  $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-ra-0-pc-pc-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf00. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id92">
<h3>Description<a class="headerlink" href="#id92" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id93">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-ra-ne-0-pc-eq-pc-plus-value">
<span id="id94"></span><h2>if any $rA != 0  $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-ra-ne-0-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf01. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id95">
<h3>Description<a class="headerlink" href="#id95" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id96">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-ra-lt-0-pc-eq-pc-plus-value">
<span id="id97"></span><h2>if any $rA &lt; 0   $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-ra-lt-0-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf02. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id98">
<h3>Description<a class="headerlink" href="#id98" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id99">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-ra-ge-0-pc-eq-pc-plus-value">
<span id="id100"></span><h2>if any $rA &gt;= 0  $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-ra-ge-0-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf03. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id101">
<h3>Description<a class="headerlink" href="#id101" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id102">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-ra-gt-0-pc-eq-pc-plus-value">
<span id="id103"></span><h2>if any $rA &gt; 0   $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-ra-gt-0-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf04. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id104">
<h3>Description<a class="headerlink" href="#id104" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id105">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-ra-le-0-pc-eq-pc-plus-value">
<span id="id106"></span><h2>if any $rA &lt;= 0  $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-ra-le-0-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf05. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id107">
<h3>Description<a class="headerlink" href="#id107" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id108">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-ra-0-pc-pc-value">
<span id="if-all-ra-eq-0-pc-eq-pc-plus-value"></span><h2>if all $rA == 0  $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-ra-0-pc-pc-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf08. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id109">
<h3>Description<a class="headerlink" href="#id109" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id110">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-ra-ne-0-pc-eq-pc-plus-value">
<span id="id111"></span><h2>if all $rA != 0  $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-ra-ne-0-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf09. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id112">
<h3>Description<a class="headerlink" href="#id112" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id113">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-ra-lt-0-pc-eq-pc-plus-value">
<span id="id114"></span><h2>if all $rA &lt; 0   $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-ra-lt-0-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf0a. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id115">
<h3>Description<a class="headerlink" href="#id115" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id116">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-ra-ge-0-pc-eq-pc-plus-value">
<span id="id117"></span><h2>if all $rA &gt;= 0  $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-ra-ge-0-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf0b. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id118">
<h3>Description<a class="headerlink" href="#id118" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id119">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-ra-gt-0-pc-eq-pc-plus-value">
<span id="id120"></span><h2>if all $rA &gt; 0   $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-ra-gt-0-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf0c. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id121">
<h3>Description<a class="headerlink" href="#id121" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id122">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-ra-le-0-pc-eq-pc-plus-value">
<span id="id123"></span><h2>if all $rA &lt;= 0  $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-ra-le-0-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf0d. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id124">
<h3>Description<a class="headerlink" href="#id124" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id125">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-rb-ra-pc-pc-value">
<span id="if-any-rb-eq-ra-pc-eq-pc-plus-value"></span><h2>if any $rB == $rA   $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-rb-ra-pc-pc-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf1.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id126">
<h3>Description<a class="headerlink" href="#id126" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id127">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-rb-ne-ra-pc-eq-pc-plus-value">
<span id="id128"></span><h2>if any $rB != $rA   $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-rb-ne-ra-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf2.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id129">
<h3>Description<a class="headerlink" href="#id129" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id130">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-signed-rb-ra-pc-pc-value">
<span id="if-any-signed-rb-lt-ra-pc-eq-pc-plus-value"></span><h2>if any signed $rB &lt; $rA  $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-signed-rb-ra-pc-pc-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf3.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id131">
<h3>Description<a class="headerlink" href="#id131" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, an signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id132">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-signed-rb-ge-ra-pc-eq-pc-plus-value">
<span id="id133"></span><h2>if any signed $rB &gt;= $rA $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-signed-rb-ge-ra-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf4.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id134">
<h3>Description<a class="headerlink" href="#id134" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id135">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-rb-lt-ra-pc-eq-pc-plus-value">
<span id="id136"></span><h2>if any $rB &lt; $rA    $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-rb-lt-ra-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf5.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id137">
<h3>Description<a class="headerlink" href="#id137" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a unsigned comparison is performed, even for VSINT16S and VSINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id138">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-any-rb-ge-ra-pc-eq-pc-plus-value">
<span id="id139"></span><h2>if any $rB &gt;= $rA   $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-any-rb-ge-ra-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf6.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id140">
<h3>Description<a class="headerlink" href="#id140" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a unsigned comparison is performed, even for VSINT16S and VSINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id141">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-rb-ra-pc-pc-value">
<span id="if-all-rb-eq-ra-pc-eq-pc-plus-value"></span><h2>if all $rB == $rA   $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-rb-ra-pc-pc-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf9.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id142">
<h3>Description<a class="headerlink" href="#id142" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id143">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-rb-ne-ra-pc-eq-pc-plus-value">
<span id="id144"></span><h2>if all $rB != $rA   $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-rb-ne-ra-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xfa.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id145">
<h3>Description<a class="headerlink" href="#id145" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id146">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-signed-rb-ra-pc-pc-value">
<span id="if-all-signed-rb-lt-ra-pc-eq-pc-plus-value"></span><h2>if all signed $rB &lt; $rA  $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-signed-rb-ra-pc-pc-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xfb.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id147">
<h3>Description<a class="headerlink" href="#id147" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id148">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-signed-rb-ge-ra-pc-eq-pc-plus-value">
<span id="id149"></span><h2>if all signed $rB &gt;= $rA $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-signed-rb-ge-ra-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xfc.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id150">
<h3>Description<a class="headerlink" href="#id150" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a signed comparison is performed, even for VUINT16S and VUINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id151">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-rb-lt-ra-pc-eq-pc-plus-value">
<span id="id152"></span><h2>if all $rB &lt; $rA    $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-rb-lt-ra-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xfd.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id153">
<h3>Description<a class="headerlink" href="#id153" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a unsigned comparison is performed, even for VSINT16S and VSINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id154">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-all-rb-ge-ra-pc-eq-pc-plus-value">
<span id="id155"></span><h2>if all $rB &gt;= $rA   $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-all-rb-ge-ra-pc-eq-pc-plus-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xfe.. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id156">
<h3>Description<a class="headerlink" href="#id156" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#cbranch-type-handling"><span class="std std-ref">conditional branch type handling</span></a> to determine the source operand types. It then evaluates the condition: for vector types, the condition for each lane up to value based on <code class="code docutils literal notranslate"><span class="pre">VEND</span></code> is evaluated and then aggregated. For scalar types, a single comparison is performed. For fixed point types, a unsigned comparison is performed, even for VSINT16S and VSINT8S types.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">VSTART</span></code> is ignored during the comparison. If the instruction is retried, all lanes are compared again.</p>
</div>
<p>If the condition evaluates true, the branch is taken. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65534, in increments of 2 bytes.</p>
<div class="admonition-todo admonition" id="id157">
<p class="admonition-title">Todo</p>
<p>How to handle NaN and INF values? Should we have special branches for those?</p>
</div>
</section>
</section>
<section id="if-ra-c-1-pc-pc-value">
<span id="if-ra-c-eq-1-pc-eq-pc-plus-value"></span><h2>if $rA[C]  == 1 $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-ra-c-1-pc-pc-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf.f. 0x****</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id158">
<h3>Description<a class="headerlink" href="#id158" title="Permalink to this headline"></a></h3>
<p>Conditional branch operation. If bit-position C of <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> is set, the instruction flow is branched. The comparison is type-independent. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65535, in increments of 2 bytes.</p>
<p>The value of ‘C’ is coded in FIELD_C in using the following table:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>C</p></th>
<th class="head"><p>FIELD_C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>9</p></td>
</tr>
<tr class="row-even"><td><p>a</p></td>
<td><p>14</p></td>
</tr>
<tr class="row-odd"><td><p>b</p></td>
<td><p>15</p></td>
</tr>
<tr class="row-even"><td><p>c</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-odd"><td><p>d</p></td>
<td><p>30</p></td>
</tr>
<tr class="row-even"><td><p>e</p></td>
<td><p>31</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="if-rb-c-0-pc-pc-value">
<span id="if-rb-c-eq-0-pc-eq-pc-plus-value"></span><h2>if $rB[C]  == 0 $pc &lt;- $pc + VALUE<a class="headerlink" href="#if-rb-c-0-pc-pc-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xf..f 0x****</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id159">
<h3>Description<a class="headerlink" href="#id159" title="Permalink to this headline"></a></h3>
<p>Conditional branch operation. If bit-position C of <code class="code docutils literal notranslate"><span class="pre">$rB</span></code> is not set, the instruction flow is branched. The comparison is type-independent. The value of FIELD_E is computed as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">FIELD_E</span> <span class="o">=</span> <span class="p">(</span><span class="n">VALUE</span> <span class="o">&amp;</span> <span class="mh">0xfffe</span><span class="p">)</span> <span class="o">|</span> <span class="p">((</span><span class="n">VALUE</span> <span class="o">&gt;&gt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>In other words, the MSB of VALUE is copied to the LSB of FIELD_E, then the value is truncated to 16 bits. The relative branch target thus can be between -65536 and 65535, in increments of 2 bytes.</p>
<p>The value of ‘C’ is coded in FIELD_C in using the following table:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 32%" />
<col style="width: 68%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>C</p></th>
<th class="head"><p>FIELD_C</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>0</p></td>
<td><p>0</p></td>
</tr>
<tr class="row-odd"><td><p>1</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>2</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>3</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-even"><td><p>4</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-odd"><td><p>5</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-even"><td><p>6</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-odd"><td><p>7</p></td>
<td><p>7</p></td>
</tr>
<tr class="row-even"><td><p>8</p></td>
<td><p>8</p></td>
</tr>
<tr class="row-odd"><td><p>9</p></td>
<td><p>9</p></td>
</tr>
<tr class="row-even"><td><p>a</p></td>
<td><p>14</p></td>
</tr>
<tr class="row-odd"><td><p>b</p></td>
<td><p>15</p></td>
</tr>
<tr class="row-even"><td><p>c</p></td>
<td><p>16</p></td>
</tr>
<tr class="row-odd"><td><p>d</p></td>
<td><p>30</p></td>
</tr>
<tr class="row-even"><td><p>e</p></td>
<td><p>31</p></td>
</tr>
</tbody>
</table>
</section>
</section>
<section id="mem32-rs-tiny-offset-rd">
<span id="mem-rs-plus-tiny-offset-eq-rd"></span><h2>MEM32[$rS + tiny OFFSET] &lt;- $rD<a class="headerlink" href="#mem32-rs-tiny-offset-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.c**</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>    <span class="n">FIELD_C</span>    <span class="o">|</span>            <span class="n">OFS</span>            <span class="o">|</span> <span class="n">S</span> <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id160">
<h3>Description<a class="headerlink" href="#id160" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine which parts of the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> to store at memory location <code class="code docutils literal notranslate"><span class="pre">$rS</span> <span class="pre">+</span> <span class="pre">OFFSET</span></code>. The field OFS is computed by dividing OFFSET by four, then truncating it to 7 bits. Thus, the offset range of -256 to 252 is supported in steps of 4. The base register, <code class="code docutils literal notranslate"><span class="pre">$rS</span></code> is <code class="code docutils literal notranslate"><span class="pre">$r12</span></code> (<code class="code docutils literal notranslate"><span class="pre">$fp</span></code>) if field S is 0, <code class="code docutils literal notranslate"><span class="pre">$r13</span></code> (<code class="code docutils literal notranslate"><span class="pre">$sp</span></code>) otherwise.</p>
<p>This instruction is useful for stack-frame manipulations.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-mem32-rs-tiny-offset">
<span id="rd-eq-mem-rs-plus-tiny-offset"></span><h2>$rD &lt;- MEM32[$rS + tiny OFFSET]<a class="headerlink" href="#rd-mem32-rs-tiny-offset" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.d**</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
<span class="o">|</span>    <span class="n">FIELD_D</span>    <span class="o">|</span>    <span class="n">FIELD_C</span>    <span class="o">|</span>            <span class="n">OFS</span>            <span class="o">|</span> <span class="n">S</span> <span class="o">|</span>
<span class="o">+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+</span>
</pre></div>
</div>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id161">
<h3>Description<a class="headerlink" href="#id161" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine which parts of the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> to load from memory location <code class="code docutils literal notranslate"><span class="pre">$rS</span> <span class="pre">+</span> <span class="pre">OFFSET</span></code>. The field OFS is computed by dividing OFFSET by four, then truncating it to 7 bits. Thus, the offset range of -256 to 252 is supported in steps of 4. The base register, <code class="code docutils literal notranslate"><span class="pre">$rS</span></code> is <code class="code docutils literal notranslate"><span class="pre">$r12</span></code> (<code class="code docutils literal notranslate"><span class="pre">$fp</span></code>) if field S is 0, <code class="code docutils literal notranslate"><span class="pre">$r13</span></code> (<code class="code docutils literal notranslate"><span class="pre">$sp</span></code>) otherwise.</p>
<p>This instruction is useful for stack-frame manipulations.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="inv-ra">
<span id="id162"></span><h2>INV[$rA]<a class="headerlink" href="#inv-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x1ee.</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id163">
<h3>Description<a class="headerlink" href="#id163" title="Permalink to this headline"></a></h3>
<p>Invalidates any data- or instruction-cache lines that contain the logical address corresponding to the value of <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. Cache invalidation applies to both L1 and L2 level caches. System-level caches (L3), if exist are not invalidated. In a multi-processor system, only local caches (caches that are in the path-to-memory for the core executing the instruction) are invalidated.</p>
<p>Dirty lines in data-caches are flushed to memory as they are invalidated.</p>
<p>The implementation is not allowed to throw exceptions even if the memory location violates access permissions. In these cases, the invalidation request is silently ignored.</p>
</section>
</section>
<section id="pc-mem32-ra">
<span id="pc-eq-mem-ra"></span><h2>$pc &lt;- MEM32[$rA]<a class="headerlink" href="#pc-mem32-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x2ee.</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id164">
<h3>Description<a class="headerlink" href="#id164" title="Permalink to this headline"></a></h3>
<p>Loads the 32-bit value from memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. The value stored in <code class="code docutils literal notranslate"><span class="pre">$pc</span></code>. This is an indirect branch.</p>
<p>The LSB of the call target address carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is not aligned to a 32-bit word boundary, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="tpc-mem32-ra">
<span id="tpc-eq-mem-ra"></span><h2>$tpc &lt;- MEM32[$rA]<a class="headerlink" href="#tpc-mem32-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x3ee.</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id165">
<h3>Description<a class="headerlink" href="#id165" title="Permalink to this headline"></a></h3>
<p>Loads the 32-bit value from memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. The value stored in <code class="code docutils literal notranslate"><span class="pre">$tpc</span></code>. This is an indirect branch in TASK mode.</p>
<p>The LSB of the call target address carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is not aligned to a 32-bit word boundary, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="call-mem32-ra">
<span id="call-eq-mem-ra"></span><h2>call MEM32[$rA]<a class="headerlink" href="#call-mem32-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x4ee.</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id166">
<h3>Description<a class="headerlink" href="#id166" title="Permalink to this headline"></a></h3>
<p>Loads the 32-bit value from memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. The value stored in <code class="code docutils literal notranslate"><span class="pre">$pc</span></code>. The current value of <code class="code docutils literal notranslate"><span class="pre">$pc</span></code> is loaded into <code class="code docutils literal notranslate"><span class="pre">$lr</span></code>. This is an indirect call operation.</p>
<p>The LSB of the call target address carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is not aligned to a 32-bit word boundary, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="inv-ra-value">
<span id="inv-ra-plus-value"></span><h2>INV[$rA + VALUE]<a class="headerlink" href="#inv-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x1fe. 0x****</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id167">
<h3>Description<a class="headerlink" href="#id167" title="Permalink to this headline"></a></h3>
<p>Invalidates any data- or instruction-cache lines that contain the logical address corresponding to the value of <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>. Cache invalidation applies to both L1 and L2 level caches. System-level caches (L3), if exist are not invalidated. In a multi-processor system, only local caches (caches that are in the path-to-memory for the core executing the instruction) are invalidated.</p>
<p>The value of FIELD_E is sign-extended prior to addition to the base register <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. Thus an offset range of -32768 to 32767 is supported.</p>
<p>Dirty lines in data-caches are flushed to memory as they are invalidated.</p>
<p>The implementation is not allowed to throw exceptions even if the memory location violates access permissions. In these cases, the invalidation request is silently ignored.</p>
</section>
</section>
<section id="pc-mem32-ra-value">
<span id="pc-eq-mem-ra-plus-value"></span><h2>$pc &lt;- MEM32[$rA + VALUE]<a class="headerlink" href="#pc-mem32-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x2fe. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id168">
<h3>Description<a class="headerlink" href="#id168" title="Permalink to this headline"></a></h3>
<p>Loads the 32-bit value from memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>. The value stored in <code class="code docutils literal notranslate"><span class="pre">$pc</span></code>. This is an indirect branch.</p>
<p>The value of FIELD_E is sign-extended prior to addition to the base register <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. Thus an offset range of -32768 to 32767 is supported.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is not aligned to a 32-bit word boundary, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="tpc-mem32-ra-value">
<span id="tpc-eq-mem-ra-plus-value"></span><h2>$tpc &lt;- MEM32[$rA + VALUE]<a class="headerlink" href="#tpc-mem32-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x3fe. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id169">
<h3>Description<a class="headerlink" href="#id169" title="Permalink to this headline"></a></h3>
<p>Loads the 32-bit value from memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>. The value stored in <code class="code docutils literal notranslate"><span class="pre">$tpc</span></code>. This is an indirect branch in TASK mode.</p>
<p>The value of FIELD_E is sign-extended prior to addition to the base register <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. Thus an offset range of -32768 to 32767 is supported.</p>
<p>The LSB of the branch target address carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is not aligned to a 32-bit word boundary, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="call-mem32-ra-value">
<span id="call-mem-ra-plus-value"></span><h2>call MEM32[$rA + VALUE]<a class="headerlink" href="#call-mem32-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x4fe. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id170">
<h3>Description<a class="headerlink" href="#id170" title="Permalink to this headline"></a></h3>
<p>Loads the 32-bit value from memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>. The value stored in <code class="code docutils literal notranslate"><span class="pre">$pc</span></code>. The current value of <code class="code docutils literal notranslate"><span class="pre">$pc</span></code> is loaded into <code class="code docutils literal notranslate"><span class="pre">$lr</span></code>. This is an indirect call operation.</p>
<p>The value of FIELD_E is sign-extended prior to addition to the base register <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. Thus an offset range of -32768 to 32767 is supported.</p>
<p>The LSB of the call target address carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is not aligned to a 32-bit word boundary, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="inv-value">
<span id="id171"></span><h2>INV[VALUE]<a class="headerlink" href="#inv-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x1fef 0x**** 0x****</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: No</p>
<section id="id172">
<h3>Description<a class="headerlink" href="#id172" title="Permalink to this headline"></a></h3>
<p>Invalidates any data- or instruction-cache lines that contain the logical address corresponding to the value of <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>. Cache invalidation applies to both L1 and L2 level caches. System-level caches (L3), if exist are not invalidated. In a multi-processor system, only local caches (caches that are in the path-to-memory for the core executing the instruction) are invalidated.</p>
<p>Dirty lines in data-caches are flushed to memory as they are invalidated.</p>
<p>The implementation is not allowed to throw exceptions even if the memory location violates access permissions. In these cases, the invalidation request is silently ignored.</p>
</section>
</section>
<section id="pc-mem32-value">
<span id="pc-eq-mem-value"></span><h2>$pc &lt;- MEM32[VALUE]<a class="headerlink" href="#pc-mem32-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x2fef 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id173">
<h3>Description<a class="headerlink" href="#id173" title="Permalink to this headline"></a></h3>
<p>Loads the 32-bit value from memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>. The value stored in <code class="code docutils literal notranslate"><span class="pre">$pc</span></code>. This is an indirect branch.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is not aligned to a 32-bit word boundary, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="tpc-mem32-value">
<span id="tpc-eq-mem-value"></span><h2>$tpc &lt;- MEM32[VALUE]<a class="headerlink" href="#tpc-mem32-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x3fef 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id174">
<h3>Description<a class="headerlink" href="#id174" title="Permalink to this headline"></a></h3>
<p>Loads the 32-bit value from memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>. The value stored in <code class="code docutils literal notranslate"><span class="pre">$tpc</span></code>. This is an indirect branch in TASK mode.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is not aligned to a 32-bit word boundary, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="call-mem32-value">
<span id="call-mem-value"></span><h2>call MEM32[VALUE]<a class="headerlink" href="#call-mem32-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x4fef 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: No</p>
<section id="id175">
<h3>Description<a class="headerlink" href="#id175" title="Permalink to this headline"></a></h3>
<p>Loads the 32-bit value from memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>. The value stored in <code class="code docutils literal notranslate"><span class="pre">$pc</span></code>. The current value of <code class="code docutils literal notranslate"><span class="pre">$pc</span></code> is loaded into <code class="code docutils literal notranslate"><span class="pre">$lr</span></code>. This is an indirect call operation.</p>
<p>The LSB of the call target address carries implementation-defined meaning, including potential exceptions. If the implementation doesn’t define a meaning for the LSB, it is ignored and no exceptions are raised.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is not aligned to a 32-bit word boundary, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-mem8-ra">
<span id="rd-eq-mem8-ra"></span><h2>$rD &lt;- MEM8[$rA]<a class="headerlink" href="#rd-mem8-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.e4.</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id176">
<h3>Description<a class="headerlink" href="#id176" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, an 8-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>, zero-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions.</p>
</section>
</section>
<section id="rd-mem16-ra">
<span id="rd-eq-mem16-ra"></span><h2>$rD &lt;- MEM16[$rA]<a class="headerlink" href="#rd-mem16-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.e5.</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id177">
<h3>Description<a class="headerlink" href="#id177" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, a 16-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>, zero-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-mem32-ra">
<span id="rd-eq-mem-ra"></span><h2>$rD &lt;- MEM32[$rA]<a class="headerlink" href="#rd-mem32-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.e6.</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id178">
<h3>Description<a class="headerlink" href="#id178" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine which parts of the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> to load from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-memll-ra">
<span id="rd-eq-memll-ra"></span><h2>$rD &lt;- MEMLL[$rA]<a class="headerlink" href="#rd-memll-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.e7.</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id179">
<h3>Description<a class="headerlink" href="#id179" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is load from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. If the load is permitted to proceed, a 32-bit value is loaded from memory and placed in <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>, while a load-lock is placed on the memory location.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="mem8-ra-rd">
<span id="mem8-ra-eq-rd"></span><h2>MEM8[$rA] &lt;- $rD<a class="headerlink" href="#mem8-ra-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.e8.</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id180">
<h3>Description<a class="headerlink" href="#id180" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine if <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> can be stored at memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. Only the lowest 8-bits of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> are stored.</p>
<p>This store operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions.</p>
</section>
</section>
<section id="mem16-ra-rd">
<span id="mem16-ra-eq-rd"></span><h2>MEM16[$rA] &lt;- $rD<a class="headerlink" href="#mem16-ra-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.e9.</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id181">
<h3>Description<a class="headerlink" href="#id181" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine if <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> can be stored at memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>. Only the lowest 16 bits of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> are stored.</p>
<p>This store operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="mem32-ra-rd">
<span id="mem-ra-eq-rd"></span><h2>MEM32[$rA] &lt;- $rD<a class="headerlink" href="#mem32-ra-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.ea.</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id182">
<h3>Description<a class="headerlink" href="#id182" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine which parts of the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> to store at memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="memsc-ra-rd">
<span id="memsc-ra-eq-rd"></span><h2>MEMSC[$rA] &lt;- $rD<a class="headerlink" href="#memsc-ra-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.eb.</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id183">
<h3>Description<a class="headerlink" href="#id183" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine if the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is stored at memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>.  If the store is permitted to proceed, the value of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is stored in the memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>, if and only if a still valid load-lock exists for the same address for the same processor. If such a lock is not found, the store fails and no memory update is performed.</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is set to 0 if the store succeeded and to non-zero if it failed. The actual non-zero value is implementation-defined and is not required to be constant, only that it is never zero. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is set to INT32.</p>
<p>This store operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised. In case of an exception, neither the existence of a lock nor the value stored in memory is altered.</p>
</section>
</section>
<section id="rd-smem8-ra">
<span id="rd-eq-smem8-ra"></span><h2>$rD &lt;- SMEM8[$rA]<a class="headerlink" href="#rd-smem8-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.ec.</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id184">
<h3>Description<a class="headerlink" href="#id184" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, an 8-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>, sign-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions.</p>
</section>
</section>
<section id="rd-smem16-ra">
<span id="rd-eq-smem16-ra"></span><h2>$rD &lt;- SMEM16[$rA]<a class="headerlink" href="#rd-smem16-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.ed.</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id185">
<h3>Description<a class="headerlink" href="#id185" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, a 16-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>, sign-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-mem8-ra-value">
<span id="rd-eq-mem8-ra-plus-value"></span><h2>$rD &lt;- MEM8[$rA + VALUE]<a class="headerlink" href="#rd-mem8-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f4. 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id186">
<h3>Description<a class="headerlink" href="#id186" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, an 8-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>, zero-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VALUE</span></code> is computed from FIELD_e by sign-extending it to 32 bits.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions.</p>
</section>
</section>
<section id="rd-mem8-value">
<span id="rd-eq-mem8-value"></span><h2>$rD &lt;- MEM8[VALUE]<a class="headerlink" href="#rd-mem8-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f4f 0x**** 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id187">
<h3>Description<a class="headerlink" href="#id187" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, an 8-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>, zero-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions.</p>
</section>
</section>
<section id="rd-mem16-ra-value">
<span id="rd-eq-mem16-ra-plus-value"></span><h2>$rD &lt;- MEM16[$rA + VALUE]<a class="headerlink" href="#rd-mem16-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f5. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id188">
<h3>Description<a class="headerlink" href="#id188" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, a 16-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>, zero-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VALUE</span></code> is computed from FIELD_e by sign-extending it to 32 bits.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-mem16-value">
<span id="rd-eq-mem16-value"></span><h2>$rD &lt;- MEM16[VALUE]<a class="headerlink" href="#rd-mem16-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f5f 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id189">
<h3>Description<a class="headerlink" href="#id189" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, a 16-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>, zero-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-mem32-ra-value">
<span id="rd-eq-mem-ra-plus-value"></span><h2>$rD &lt;- MEM32[$rA + VALUE]<a class="headerlink" href="#rd-mem32-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f6. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id190">
<h3>Description<a class="headerlink" href="#id190" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine which parts of the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> to load from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VALUE</span></code> is computed from FIELD_e by sign-extending it to 32 bits.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-mem32-value">
<span id="rd-eq-mem-value"></span><h2>$rD &lt;- MEM32[VALUE]<a class="headerlink" href="#rd-mem32-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f6f 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id191">
<h3>Description<a class="headerlink" href="#id191" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine which parts of the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> to load from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span></code>.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-memll-ra-value">
<span id="rd-eq-memll-ra-plus-value"></span><h2>$rD &lt;- MEMLL[$rA + VALUE]<a class="headerlink" href="#rd-memll-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f7. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id192">
<h3>Description<a class="headerlink" href="#id192" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is load from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>. If the load is permitted to proceed, a 32-bit value is loaded from memory and placed in <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>, while a load-lock is placed on the memory location.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VALUE</span></code> is computed from FIELD_e by sign-extending it to 32 bits.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-memll-value">
<span id="rd-eq-memll-value"></span><h2>$rD &lt;- MEMLL[VALUE]<a class="headerlink" href="#rd-memll-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f7f 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id193">
<h3>Description<a class="headerlink" href="#id193" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is load from memory location <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>. If the load is permitted to proceed, a 32-bit value is loaded from memory and placed in <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>, while a load-lock is placed on the memory location.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="mem8-ra-value-rd">
<span id="mem8-ra-plus-value-eq-rd"></span><h2>MEM8[$rA + VALUE] &lt;- $rD<a class="headerlink" href="#mem8-ra-value-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f8. 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id194">
<h3>Description<a class="headerlink" href="#id194" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine if <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> can be stored at memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>. Only the lowest 8-bits of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> are stored.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VALUE</span></code> is computed from FIELD_e by sign-extending it to 32 bits.</p>
<p>This store operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions.</p>
</section>
</section>
<section id="mem8-value-rd">
<span id="mem8-value-eq-rd"></span><h2>MEM8[VALUE] &lt;- $rD<a class="headerlink" href="#mem8-value-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f8f 0x**** 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id195">
<h3>Description<a class="headerlink" href="#id195" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine if <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> can be stored at memory location <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>. Only the lowest 8-bits of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> are stored.</p>
<p>This store operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions.</p>
</section>
</section>
<section id="mem16-ra-value-rd">
<span id="mem16-ra-plus-value-eq-rd"></span><h2>MEM16[$rA + VALUE] &lt;- $rD<a class="headerlink" href="#mem16-ra-value-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f9. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id196">
<h3>Description<a class="headerlink" href="#id196" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine if <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> can be stored at memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>. Only the lowest 16 bits of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> are stored.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VALUE</span></code> is computed from FIELD_e by sign-extending it to 32 bits.</p>
<p>This store operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="mem16-value-rd">
<span id="mem16-value-eq-rd"></span><h2>MEM16[VALUE] &lt;- $rD<a class="headerlink" href="#mem16-value-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.f9f 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id197">
<h3>Description<a class="headerlink" href="#id197" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine if <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> can be stored at memory location <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>. Only the lowest 16 bits of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> are stored.</p>
<p>This store operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="mem32-ra-value-rd">
<span id="mem-ra-plus-value-eq-rd"></span><h2>MEM32[$rA + VALUE] &lt;- $rD<a class="headerlink" href="#mem32-ra-value-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.fa. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id198">
<h3>Description<a class="headerlink" href="#id198" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine which parts of the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> to store at memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VALUE</span></code> is computed from FIELD_e by sign-extending it to 32 bits.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="mem32-value-rd">
<span id="mem-value-eq-rd"></span><h2>MEM32[VALUE] &lt;- $rD<a class="headerlink" href="#mem32-value-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.faf 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id199">
<h3>Description<a class="headerlink" href="#id199" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine which parts of the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> to store at memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="memsc-ra-value-rd">
<span id="memsc-ra-plus-value-eq-rd"></span><h2>MEMSC[$rA + VALUE] &lt;- $rD<a class="headerlink" href="#memsc-ra-value-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.fb. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id200">
<h3>Description<a class="headerlink" href="#id200" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine if the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is stored at memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>.  If the store is permitted to proceed, the value of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is stored in the memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>, if and only if a still valid load-lock exists for the same address for the same processor. If such a lock is not found, the store fails and no memory update is performed.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VALUE</span></code> is computed from FIELD_e by sign-extending it to 32 bits.</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is set to 0 if the store succeeded and to non-zero if it failed. The actual non-zero value is implementation-defined and is not required to be constant, only that it is never zero. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is set to INT32.</p>
<p>This store operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised. In case of an exception, neither the existence of a lock nor the value stored in memory is altered.</p>
</section>
</section>
<section id="memsc-value-rd">
<span id="memsc-value-eq-rd"></span><h2>MEMSC[VALUE] &lt;- $rD<a class="headerlink" href="#memsc-value-rd" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.fbf 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id201">
<h3>Description<a class="headerlink" href="#id201" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#store-type-handling"><span class="std std-ref">store type handling</span></a> to determine if the register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is stored at memory location <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>.  If the store is permitted to proceed, the value of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is stored in the memory location pointed to by <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>, if and only if a still valid load-lock exists for the same address for the same processor. If such a lock is not found, the store fails and no memory update is performed.</p>
<p>The value of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is set to 0 if the store succeeded and to non-zero if it failed. The actual non-zero value is implementation-defined and is not required to be constant, only that it is never zero. The type of <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is set to INT32.</p>
<p>This store operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised. In case of an exception, neither the existence of a lock nor the value stored in memory is altered.</p>
</section>
</section>
<section id="rd-smem8-ra-value">
<span id="rd-eq-smem8-ra-plus-value"></span><h2>$rD &lt;- SMEM8[$rA + VALUE]<a class="headerlink" href="#rd-smem8-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.fc. 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id202">
<h3>Description<a class="headerlink" href="#id202" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, an 8-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>, sign-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VALUE</span></code> is computed from FIELD_e by sign-extending it to 32 bits.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions.</p>
</section>
</section>
<section id="rd-smem8-value">
<span id="rd-eq-smem8-value"></span><h2>$rD &lt;- SMEM8[VALUE]<a class="headerlink" href="#rd-smem8-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.fcf 0x**** 0x****</p>
<p><em>Exceptions</em>: Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id203">
<h3>Description<a class="headerlink" href="#id203" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, an 8-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>, sign-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions.</p>
</section>
</section>
<section id="rd-smem16-ra-value">
<span id="rd-eq-smem16-ra-plus-value"></span><h2>$rD &lt;- SMEM16[$rA + VALUE]<a class="headerlink" href="#rd-smem16-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.fd. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id204">
<h3>Description<a class="headerlink" href="#id204" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, a 16-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">$rA</span> <span class="pre">+</span> <span class="pre">VALUE</span></code>, sign-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p><code class="code docutils literal notranslate"><span class="pre">VALUE</span></code> is computed from FIELD_e by sign-extending it to 32 bits.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-smem16-value">
<span id="rd-eq-smem16-value"></span><h2>$rD &lt;- SMEM16[VALUE]<a class="headerlink" href="#rd-smem16-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.fdf 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code>; Implementation defined</p>
<p><em>Type variants</em>: Yes</p>
<section id="id205">
<h3>Description<a class="headerlink" href="#id205" title="Permalink to this headline"></a></h3>
<p>This operation uses <a class="reference internal" href="#load-type-handling"><span class="std std-ref">load type handling</span></a> to determine if register <code class="code docutils literal notranslate"><span class="pre">$rD</span></code> is loaded. If the load is permitted to proceed, a 16-bit value is loaded from memory location <code class="code docutils literal notranslate"><span class="pre">VALUE</span></code>, sign-extended to 32-bits and assigned to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. The 32-bit result is written to <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>.</p>
<p>This operation only handles scalar types.</p>
<p>The implementation is allowed to throw exceptions if the memory access violates access permissions. If the resulting memory reference is unaligned, an <code class="code docutils literal notranslate"><span class="pre">exc_unaligned</span></code> exception is raised.</p>
</section>
</section>
<section id="rd-ra-rb">
<span id="rd-eq-ra-xor-rb"></span><h2>$rD &lt;- $rA ^ $rB<a class="headerlink" href="#rd-ra-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.1..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id206">
<h3>Description<a class="headerlink" href="#id206" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting types a bit-wise ‘xor’ operation is performed.</p>
</section>
</section>
<section id="rd-eq-ra-or-rb">
<span id="id207"></span><h2>$rD &lt;- $rA | $rB<a class="headerlink" href="#rd-eq-ra-or-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.2..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id208">
<h3>Description<a class="headerlink" href="#id208" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting types a bit-wise ‘or’ operation is performed.</p>
</section>
</section>
<section id="rd-eq-ra-and-rb">
<span id="id209"></span><h2>$rD &lt;- $rA &amp; $rB<a class="headerlink" href="#rd-eq-ra-and-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.3..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id210">
<h3>Description<a class="headerlink" href="#id210" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting types a bit-wise ‘and’ operation is performed.</p>
</section>
</section>
<section id="rd-eq-ra-plus-rb">
<span id="id211"></span><h2>$rD &lt;- $rA + $rB<a class="headerlink" href="#rd-eq-ra-plus-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.4..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id212">
<h3>Description<a class="headerlink" href="#id212" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting types either an integer or a float-point lane-wise addition is performed.</p>
</section>
</section>
<section id="rd-eq-ra-minus-rb">
<span id="id213"></span><h2>$rD &lt;- $rA - $rB<a class="headerlink" href="#rd-eq-ra-minus-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.5..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id214">
<h3>Description<a class="headerlink" href="#id214" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting types either an integer or a float-point subtraction is performed.</p>
</section>
</section>
<section id="rd-eq-ra-lsl-rb">
<span id="id215"></span><h2>$rD &lt;- $rA &lt;&lt; $rB<a class="headerlink" href="#rd-eq-ra-lsl-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.6..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id216">
<h3>Description<a class="headerlink" href="#id216" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#shift-type-handling"><span class="std std-ref">shift type handling</span></a> to determine the operand and destination types. Then, <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> is left-shifted by <code class="code docutils literal notranslate"><span class="pre">$rB</span></code>. 0-s are shifted in from the right.</p>
</section>
</section>
<section id="rd-eq-ra-lsr-rb">
<span id="id217"></span><h2>$rD &lt;- $rA &gt;&gt; $rB<a class="headerlink" href="#rd-eq-ra-lsr-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.7..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id218">
<h3>Description<a class="headerlink" href="#id218" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#shift-type-handling"><span class="std std-ref">shift type handling</span></a> to determine the operand and destination types. Then, <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> is right-shifted by <code class="code docutils literal notranslate"><span class="pre">$rB</span></code>. 0-s are shifted in from the left.</p>
</section>
</section>
<section id="rd-eq-ra-asr-rb">
<span id="id219"></span><h2>$rD &lt;- $rA &gt;&gt;&gt; $rB<a class="headerlink" href="#rd-eq-ra-asr-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.8..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id220">
<h3>Description<a class="headerlink" href="#id220" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#shift-type-handling"><span class="std std-ref">shift type handling</span></a> to determine the operand and destination types. Then, <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> is right-shifted by <code class="code docutils literal notranslate"><span class="pre">$rB</span></code>. The MSB of each lane is replicated as it is shifted in from the left.</p>
</section>
</section>
<section id="rd-eq-ra-times-rb">
<span id="id221"></span><h2>$rD &lt;- $rA * $rB<a class="headerlink" href="#rd-eq-ra-times-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.9..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id222">
<h3>Description<a class="headerlink" href="#id222" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting types either an integer or a float-point multiplication is performed.</p>
</section>
</section>
<section id="rd-type-name-rb">
<span id="rd-eq-type-rb"></span><h2>$rD &lt;- TYPE_NAME $rB<a class="headerlink" href="#rd-type-name-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.a..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id223">
<h3>Description<a class="headerlink" href="#id223" title="Permalink to this headline"></a></h3>
<p>Converts the value stored in <code class="code docutils literal notranslate"><span class="pre">$rB</span></code> to type ‘type’ and stores in in <code class="code docutils literal notranslate"><span class="pre">$rD</span></code>. If such conversion is not possible or an unsupported type is specified, the instruction raises a <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code> exception.</p>
<p>Type is encoded in FIELD_A.</p>
<div class="admonition-todo admonition" id="id224">
<p class="admonition-title">Todo</p>
<p>This used to be the ~$rA &amp; $rB instruction. That needs to be removed and this to be added in the toolset and Espresso.</p>
</div>
</section>
</section>
<section id="rd-tiny-rb-const">
<span id="rd-eq-tiny-rb-plus-const"></span><h2>$rD &lt;- tiny $rB + CONST<a class="headerlink" href="#rd-tiny-rb-const" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.b..</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id225">
<h3>Description<a class="headerlink" href="#id225" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting types either an integer or a float-point addition is performed.</p>
<p>FIELD_A contains the ones complement value of CONST. The valid range is -7 to 7. This value is sign-extended to 32-bits during type handling, which makes the operation rather pointless for floating-point types.</p>
</section>
</section>
<section id="rd-short-value-ra">
<span id="rd-eq-short-value-xor-ra"></span><h2>$rD &lt;- short VALUE ^ $rA<a class="headerlink" href="#rd-short-value-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.1f. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id226">
<h3>Description<a class="headerlink" href="#id226" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting types a bit-wise ‘xor’ operation is performed.</p>
</section>
</section>
<section id="rd-eq-short-value-or-ra">
<span id="id227"></span><h2>$rD &lt;- short VALUE | $rA<a class="headerlink" href="#rd-eq-short-value-or-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.2f. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id228">
<h3>Description<a class="headerlink" href="#id228" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting types a bit-wise ‘or’ operation is performed.</p>
</section>
</section>
<section id="rd-eq-short-value-and-ra">
<span id="id229"></span><h2>$rD &lt;- short VALUE &amp; $rA<a class="headerlink" href="#rd-eq-short-value-and-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.3f. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id230">
<h3>Description<a class="headerlink" href="#id230" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting types a bit-wise ‘and’ operation is performed.</p>
</section>
</section>
<section id="rd-eq-short-value-plus-ra">
<span id="id231"></span><h2>$rD &lt;- short VALUE + $rA<a class="headerlink" href="#rd-eq-short-value-plus-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.4f. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id232">
<h3>Description<a class="headerlink" href="#id232" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting types either an integer or a float-point addition is performed.</p>
</section>
</section>
<section id="rd-eq-short-value-minus-ra">
<span id="id233"></span><h2>$rD &lt;- short VALUE - $rA<a class="headerlink" href="#rd-eq-short-value-minus-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.5f. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id234">
<h3>Description<a class="headerlink" href="#id234" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting types either an integer or a float-point subtraction is performed.</p>
</section>
</section>
<section id="rd-short-ra-value">
<span id="rd-eq-short-ra-lsl-value"></span><h2>$rD &lt;- short $rA &lt;&lt; VALUE<a class="headerlink" href="#rd-short-ra-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.6f. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id235">
<h3>Description<a class="headerlink" href="#id235" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#shift-type-handling"><span class="std std-ref">shift type handling</span></a> to determine the operand and destination types. Then, <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> is left-shifted by <code class="code docutils literal notranslate"><span class="pre">$rB</span></code>. 0-s are shifted in from the right.</p>
</section>
</section>
<section id="rd-eq-short-ra-lsr-value">
<span id="id236"></span><h2>$rD &lt;- short $rA &gt;&gt; VALUE<a class="headerlink" href="#rd-eq-short-ra-lsr-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.7f. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id237">
<h3>Description<a class="headerlink" href="#id237" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#shift-type-handling"><span class="std std-ref">shift type handling</span></a> to determine the operand and destination types. Then, <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> is right-shifted by <code class="code docutils literal notranslate"><span class="pre">$rB</span></code>. 0-s are shifted in from the left.</p>
</section>
</section>
<section id="rd-eq-short-ra-asr-value">
<span id="id238"></span><h2>$rD &lt;- short $rA &gt;&gt;&gt; VALUE<a class="headerlink" href="#rd-eq-short-ra-asr-value" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.8f. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id239">
<h3>Description<a class="headerlink" href="#id239" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#shift-type-handling"><span class="std std-ref">shift type handling</span></a> to determine the operand and destination types. Then, <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> is right-shifted by <code class="code docutils literal notranslate"><span class="pre">$rB</span></code>. The MSB of each lane is replicated as it is shifted in from the left.</p>
</section>
</section>
<section id="rd-eq-short-value-times-ra">
<span id="id240"></span><h2>$rD &lt;- short VALUE * $rA<a class="headerlink" href="#rd-eq-short-value-times-ra" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.9f. 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id241">
<h3>Description<a class="headerlink" href="#id241" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting types either an integer or a float-point multiplication is performed.</p>
</section>
</section>
<section id="rd-value-rb">
<span id="rd-eq-value-xor-rb"></span><h2>$rD &lt;- VALUE ^ $rB<a class="headerlink" href="#rd-value-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.1.f 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id242">
<h3>Description<a class="headerlink" href="#id242" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting types a bit-wise ‘xor’ operation is performed.</p>
</section>
</section>
<section id="rd-eq-value-or-rb">
<span id="id243"></span><h2>$rD &lt;- VALUE | $rB<a class="headerlink" href="#rd-eq-value-or-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.2.f 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id244">
<h3>Description<a class="headerlink" href="#id244" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting types a bit-wise ‘or’ operation is performed.</p>
</section>
</section>
<section id="rd-eq-value-and-rb">
<span id="id245"></span><h2>$rD &lt;- VALUE &amp; $rB<a class="headerlink" href="#rd-eq-value-and-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.3.f 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id246">
<h3>Description<a class="headerlink" href="#id246" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#logic-type-handling"><span class="std std-ref">logic type handling</span></a> to determine operand and destination types. On the resulting types a bit-wise ‘and’ operation is performed.</p>
</section>
</section>
<section id="rd-eq-value-plus-rb">
<span id="id247"></span><h2>$rD &lt;- VALUE + $rB<a class="headerlink" href="#rd-eq-value-plus-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.4.f 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id248">
<h3>Description<a class="headerlink" href="#id248" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting types either an integer or a float-point addition is performed.</p>
</section>
</section>
<section id="rd-eq-value-minus-rb">
<span id="id249"></span><h2>$rD &lt;- VALUE - $rB<a class="headerlink" href="#rd-eq-value-minus-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.5.f 0x**** 0x****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id250">
<h3>Description<a class="headerlink" href="#id250" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting types either an integer or a float-point subtraction is performed.</p>
</section>
</section>
<section id="rd-eq-value-lsl-rb">
<span id="id251"></span><h2>$rD &lt;- VALUE &lt;&lt; $rB<a class="headerlink" href="#rd-eq-value-lsl-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.6.f 0x**** 0x*****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id252">
<h3>Description<a class="headerlink" href="#id252" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#shift-type-handling"><span class="std std-ref">shift type handling</span></a> to determine the operand and destination types. Then, <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> is left-shifted by <code class="code docutils literal notranslate"><span class="pre">$rB</span></code>. 0-s are shifted in from the right.</p>
</section>
</section>
<section id="rd-eq-value-lsr-rb">
<span id="id253"></span><h2>$rD &lt;- VALUE &gt;&gt; $rB<a class="headerlink" href="#rd-eq-value-lsr-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.7.f 0x**** 0x*****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id254">
<h3>Description<a class="headerlink" href="#id254" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#shift-type-handling"><span class="std std-ref">shift type handling</span></a> to determine the operand and destination types. Then, <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> is right-shifted by <code class="code docutils literal notranslate"><span class="pre">$rB</span></code>. 0-s are shifted in from the left.</p>
</section>
</section>
<section id="rd-eq-value-asr-rb">
<span id="id255"></span><h2>$rD &lt;- VALUE &gt;&gt;&gt; $rB<a class="headerlink" href="#rd-eq-value-asr-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.8.f 0x**** 0x*****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id256">
<h3>Description<a class="headerlink" href="#id256" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#shift-type-handling"><span class="std std-ref">shift type handling</span></a> to determine the operand and destination types. Then, <code class="code docutils literal notranslate"><span class="pre">$rA</span></code> is right-shifted by <code class="code docutils literal notranslate"><span class="pre">$rB</span></code>. The MSB of each lane is replicated as it is shifted in from the left.</p>
</section>
</section>
<section id="rd-eq-value-times-rb">
<span id="id257"></span><h2>$rD &lt;- VALUE * $rB<a class="headerlink" href="#rd-eq-value-times-rb" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0x.9.f 0x**** 0x*****</p>
<p><em>Exceptions</em>: <code class="code docutils literal notranslate"><span class="pre">exc_type</span></code></p>
<p><em>Type variants</em>: Yes</p>
<section id="id258">
<h3>Description<a class="headerlink" href="#id258" title="Permalink to this headline"></a></h3>
<p>The operation uses <a class="reference internal" href="#std-type-handling"><span class="std std-ref">standard type handling</span></a> to determine operand and destination types. On the resulting types either an integer or a float-point multiplication is performed.</p>
</section>
</section>
<section id="type-override-type">
<span id="type-overrides-detail"></span><h2>Type override (&lt;type&gt;)<a class="headerlink" href="#type-override-type" title="Permalink to this headline"></a></h2>
<p><em>Instruction code</em>: 0xff** …</p>
<p><em>Exceptions</em>: None</p>
<p><em>Type variants</em>: Yes</p>
<section id="id259">
<h3>Description<a class="headerlink" href="#id259" title="Permalink to this headline"></a></h3>
<p>Type override provides a way to momentarily change the apparent type of any of the operands of an instruction, without actually changing the stored type of the associated register. The override prefix changes the way types are interpreted in the immediately succeeding instruction. Any valid instruction can be preceded by a type override prefix. While in principle cascading prefix instructions is valid, this version of the ISA specifies only a single prefix instruction. The only conceivable cascading prefix sequence thus is multiple type overrides, which is invalid and raises an <code class="code docutils literal notranslate"><span class="pre">exc_unknown_inst</span></code> exception.</p>
<p>If either TYPE_A or TYPE_B is set to 0xf, the corresponding operand type is not overridden: the type from the register file is used during the subsequent operation.</p>
<p>Overriding the type of immediates is not supported. The corresponding field of the type override prefix is simply ignored for immediate operands.</p>
<p>In assembly, any appearance of an operand register can be prefixed with a type override in the form of <code class="code docutils literal notranslate"><span class="pre">(&lt;type&gt;)</span></code>. For instance:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$r4 &lt;- (INT32) $r6 * $r7
$r4 &lt;- (INT32) $r6 + (FP32) $r7
if any (FP32) $r7 &gt; 0 $pc &lt;- $pc + 10
</pre></div>
</div>
<p>In all of these cases the type of the operand is overwritten to the given type. Type overrides cannot be provided to constants. For instance the following syntax is invalid:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$r6 &lt;- (FP32) $r12 + (FP32) 0x12345768
</pre></div>
</div>
<p>The result type that is written into the destination along with its value is the result type obtained after the type overrides.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Exception behavior</em>: If a prefixed instruction throws an exception, $tpc points to the (first) prefix instruction after entering SCHEDULER mode. This allows the recovery code to decode and potentially retry the excepted instruction.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Interrupt behavior</em>: If an interrupt is handled during the execution of a prefixed instruction, $tpc points to the (first) prefix instruction after entering SCHEDULER mode.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><em>Prefix concatenation</em>: Every processor implementation has a maximum instruction length it supports. In this version of the spec, it’s 64 bits. If an instruction with all its prefixes exceeds this limit, the processor raises an <code class="code docutils literal notranslate"><span class="pre">exc_unknown_inst</span></code> exception, with $tpc pointing to the first prefix instruction. Without this provision it would be possible to create arbitrarily long instruction sequences in TASK mode. That in turn would prevent interrupts from being raised, effectively locking up the system (at least up to the point of exhausting the addressable RAM space).</p>
</div>
</section>
</section>
<section id="pseudo-instructions">
<h2>Pseudo instructions<a class="headerlink" href="#pseudo-instructions" title="Permalink to this headline"></a></h2>
<p>NOP is equivalent to $r2 &lt;- $r2 | $r2
$rD &lt;- $rS is equivalent to $rD &lt;- $rS | $rS
if any signed $rB &gt;= $rA $pc &lt;- $pc + VALUE
if any signed $rB &lt; $rA  $pc &lt;- $pc + VALUE
if any $rB &gt;= $rA   $pc &lt;- $pc + VALUE
if any $rB &lt; $rA    $pc &lt;- $pc + VALUE
if all signed $rB &gt;= $rA $pc &lt;- $pc + VALUE
if all signed $rB &lt; $rA  $pc &lt;- $pc + VALUE
if all $rB &gt;= $rA   $pc &lt;- $pc + VALUE
if all $rB &lt; $rA    $pc &lt;- $pc + VALUE</p>
</section>
</section>

    <script type="text/javascript">
        function init() {
            WaveDrom.ProcessAll();
        }
        window.onload = init;
    </script>

           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="memory_model.html" class="btn btn-neutral float-left" title="Memory Model" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="floating_point_support.html" class="btn btn-neutral float-right" title="Floating point support" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Andras Tantos.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>